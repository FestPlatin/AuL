\chapter{Dynamisches Programmieren}
Dynamische Programmierung ist eine Methode zum algorithmischen Lösen von Optimierungsproblemen.
Es kann dann erfolgreich eingesetzt werden, wenn das Optimierungsproblem aus vielen gleichartigen Teilproblemen besteht,
und eine optimale Lösung des Problems sich aus optimalen Lösungen der Teilprobleme zusammensetzt.
In der dynamischen Programmierung werden zuerst die optimalen Lösungen der kleinsten Teilprobleme direkt berechnet und dann geeignet zu einer Lösung eines nächstgrößeren Teilproblems zusammengesetzt.
Dieses Verfahren setzt man fort, bis das ursprüngliche Problem gelöst wurde.
Einmal berechnete Teilergebnisse werden in einer Tabelle gespeichert.
Bei nachfolgenden Berechnungen gleichartiger Teilprobleme wird auf diese Zwischenlösungen zurückgegriffen, anstatt sie jedes Mal neu zu berechnen.
Wird die dynamische Programmierung konsequent eingesetzt, vermeidet sie kostspielige Rekursionen, weil bekannte Teilergebnisse wiederverwendet werden.

\subsubsection{Beispiel}
Ein Läufer nimmt in jeden Schritt 1 oder 2 Stufen auf einmal.
Wieviele Möglichkeiten gibt es, \(n\) Stufen herrauf zu steigen?
\begin{eqnarray*}
t_{1} &=& 1\\
t_{2} &=& 2\\
t_{n} &=& t_{n-1} + t_{n-2}
\end{eqnarray*}
Man kann zeigen das \(t_{n} \in \mathcal{O}(1,618^{n})\) liegt.
Wenn \(t_{n}\) rekursiv berechnet wird, werden die meisten \(t_{n}\) mehrfach berechnet, siehe Abbildung \ref{fig:ProgLaufer}.
Um \(t_{n}\) durch dynamische Programmierung zu berechnen, speichert man die Werte von \(t_{n}\) in einem Feld.
Die Laufzeit beträgt somit: \(\mathcal{O}(n)\cdot\mathcal{O}(1) = \mathcal{O}(n)\).
\newpage
\begin{figure}[htbp]
	\begin{center}
		\begin{tikzpicture}
		\Tree [
			.\(t_{n}\)
			[.\(t_{n-1}\)
				[.\(t_{n-2}\) ]
				[.\(t_{n-3}\) ]
			]
			[.\(t_{n-2}\)
				[.\(t_{n-3}\) ]
				[.\(t_{n-4}\) ]
			]
		]
		\end{tikzpicture}
	\end{center}
	\caption{Verdeutlichung der mehrfachen Berechnung von Werten}
	\label{fig:ProgLaufer}
\end{figure}
\begin{figure}[htbp]
\begin{lstlisting}[language=java, caption={Beispielimplementierung in Java}]
for(i=1; i<=n; i++)
{
	if(n==1)
		t[n] = 1;
	else if(n==2)
		t[n] = 2;
	else
		t[n] = t[n-1] + t[n-2];
}
\end{lstlisting}
\end{figure}

\section{Editierdistanz}
Die Editierdistanz zwischen zwei Zeichenketten ist die minimale Anzahl von Einfüge-, Lösch- und Ersetz-Operationen, um die erste Zeichenkette in die zweite umzuwandeln.
In der Praxis wird die Editierdistanz zur Bestimmung der Ähnlichkeit von Zeichenketten beispielsweise zur Rechtschreibprüfung, DNA-Sequenzvergleich oder bei der Duplikaterkennung angewandt.

Gegeben seien zwei Strings a, b, wieviele Editieroperationen sind nötig, um a in b zu überführen?
\begin{figure}[htbp]
	\begin{center}
		\begin{tikzpicture}
			\node[cross] (1) {A};
			\node (2) [right of=1] {P};
			\node (3) [right of=2] {F};
			\node (4) [right of=3] {E};
			\node[cross] (5) [right of=4] {L};
			\node[red] (6) [right of=5] {D};
			\node[red] (7) [above of=5] {R};
			\node (8) [below of=2] {P};
			\node (9) [below of=3] {F};
			\node (10) [below of=4] {E};
			\node (11) [below of=5] {R};
			\node (12) [below of=6] {D};
		\end{tikzpicture}
	\end{center}
\end{figure}
Lösung: Die Editierdistanz beträgt 3.

Sei \(d(i,j)\) die Editierdistanz zwischen den Teilwörtern \(a_{1} \ldots a_{i}, b_{1} \ldots b_{j}\).
So gibt es folgende Möglichkeiten:
\begin{itemize}
	\item Ein Matching kann verlängert werden (MATCH)
		\begin{center}
			\begin{tikzpicture}[every node/.style={circle,inner sep=0pt}]
				\draw (0,1) -- (2,1) -- (2,1.5) -- (0,1.5);
				\draw (1.5,1) -- (1.5,1.5);
				\draw (1.75,1.2) node {\(a_{i}\)};
				\draw (0,0) -- (2,0) -- (2,.5) -- (0,.5);
				\draw (1.5,0) -- (1.5,.5);
				\draw (1.75,.2) node {\(b_{j}\)};
			\end{tikzpicture}
		\end{center}
		
		\(a_{i} = b_{j} \rightarrow\) Bewertung \(d(i-1,j-1)\)
	\item Missmatch
		\begin{center}
			\begin{tikzpicture}[every node/.style={circle,inner sep=0pt}]
				\draw (0,1) -- (2,1) -- (2,1.5) -- (0,1.5);
				\draw (1.5,1) -- (1.5,1.5);
				\draw (1.75,1.2) node {\(a_{i}\)};
				\draw (0,0) -- (2,0) -- (2,.5) -- (0,.5);
				\draw (1.5,0) -- (1.5,.5);
				\draw (1.75,.2) node {\(b_{j}\)};
			\end{tikzpicture}
		\end{center}
		
		\(a_{i} \neq b_{j} \rightarrow\) Bewertung \(d(i-1,j-1)+1\)
	\item Löschen / Hinzufügen
		\begin{center}
			\begin{tikzpicture}[every node/.style={circle,inner sep=0pt}]
				\draw (0,1) -- (2,1) -- (2,1.5) -- (0,1.5);
				\draw (1.5,1) -- (1.5,1.5);
				\draw (1.75,1.2) node {\(a_{i}\)};
				\draw (0,0) -- (1.5,0) -- (1.5,.5) -- (0,.5);
				\draw (1.25,.2) node {\(b_{j}\)};
			\end{tikzpicture}
		\end{center}
		
		Bewertung \(d(i-1,j)+1\)
		\begin{center}
			\begin{tikzpicture}[every node/.style={circle,inner sep=0pt}]
				\draw (0,1) -- (1.5,1) -- (1.5,1.5) -- (0,1.5);
				\draw (1.25,1.2) node {\(a_{i}\)};
				\draw (0,0) -- (2,0) -- (2,.5) -- (0,.5);
				\draw (1.5,0) -- (1.5,.5);
				\draw (1.75,.2) node {\(b_{j}\)};
			\end{tikzpicture}
		\end{center}
		
		Bewertung \(d(i,j-1)+1\)
\end{itemize}
Man wählt in jeden Schritt die Möglichkeit mit der besten Bewertung
\begin{equation*}
d(i,j) = \left\{
	\begin{array}{l l}
		j & \quad \text{für } i=0\\
		i & \quad \text{für } j=0\\
		\begin{array}{l l}
			\min \{&d(i-1,j-1) + 1_{a_{i} \neq b_{j}},\\
			&d(i-1,j) + 1,\\
			&d(i,j-1) + 1 \}
		\end{array} & \quad \text{für } i,j >0
  \end{array} \right.
\end{equation*}
wobei gilt:
\begin{equation*}
	  1_{a_{i} \neq b_{j}} = \left\{
	\begin{array}{l l}
		0 & \text{für } x = y \\
		1 & \text{für } x \neq y
	\end{array}
	\right.
\end{equation*}
Der Aufwand für die Berechnung in einem 2-dimensionalten Feld beträgt:
\begin{equation*}
	\underbrace{\mathcal{O}(n \cdot m)}_{\textrm{Größe der Tabelle}} \cdot \underbrace{\mathcal{O}(1)}_{\textrm{Vergleichsoperation}}
\end{equation*}

\subsubsection{Beispiel}
Berechen Sie die Edierdistanz der Wörter: APFEL, PFERD.
\begin{center}
	\begin{tabular}{c|cccccc}
		& \(\varepsilon\) & A & P & F & E & L \\ \hline
	\(\varepsilon\)		& 0 & 1 & 2 & 3 & 4 & 5 \\
	P	& 1 & 1 & 1 & 2 & 3 & 4 \\
	F	& 2 & 2 & 2 & 1 & 2 & 3 \\
	E	& 3 & 3 & 3 & 2 & 1 & 2 \\
	R	& 4 & 4 & 4 & 3 & 2 & 2 \\
	D	& 5 & 5 & 5 & 4 & 3 & \textbf{\textcolor{red}{3}}
	\end{tabular}
\end{center}

\section{Längste gemeinsame Teilffolge}
Eine längste gemeinsame Teilffolge kann durch Streichen von Zeichen erzeugt werden.
Bespiel:
\begin{figure}[htbp]
	\begin{center}
		\begin{tikzpicture}
			\node (1) {A};
			\node (2) [right of=1] {N};
			\node (3) [right of=2] {A};
			\node (4) [right of=3] {N};
			\node[cross] (5) [right of=4] {A};
			\node[cross] (6) [right of=5] {S};
			\node (8) [below of=1] {A};
			\node (9) [below of=2] {N};
			\node (10) [below of=3] {A};
			\node (11) [below of=4] {N};
			\node[cross] (12) [below of=5] {E};
			\node[cross] (13) [left of=8] {B};
		\end{tikzpicture}
	\end{center}
\end{figure}
Die längste gemeinsame Teilffolge ist in diesem Bespiel 4.


Sei \(d(i,j)\) die Länge der längsten gemeinsamen Teilffolge von \(a_{1} \ldots a_{i}, b_{1} \ldots b_{j}\).
So gibt es folgende Möglichkeiten:

\begin{itemize}
	\item Teilffolge verlängern (sodass die letzten beiden Zeichen übereinstimmen)
		\begin{center}
			\begin{tikzpicture}[every node/.style={circle,inner sep=0pt}]
				\draw (0,1) -- (2,1) -- (2,1.5) -- (0,1.5);
				\draw (1.5,1) -- (1.5,1.5);
				\draw (1.75,1.2) node {\(a_{i}\)};
				\draw (0,0) -- (2,0) -- (2,.5) -- (0,.5);
				\draw (1.5,0) -- (1.5,.5);
				\draw (1.75,.2) node {\(b_{j}\)};
			\end{tikzpicture}
		\end{center}
		
		\(a_{i} = b_{j} \rightarrow\) Bewertung: \(d(i-1,j-1)+1\)
	\item Zeichen streichen
		\begin{center}
			\begin{tikzpicture}[every node/.style={circle,inner sep=0pt}]
				\draw (0,1) -- (2,1) -- (2,1.5) -- (0,1.5);
				\draw (1.75,1.2) node {\(a_{i}\)};
				\draw (0,0) -- (2,0) -- (2,.5) -- (0,.5);
				\draw (1.75,.2) node {\(b_{j}\)};
			\end{tikzpicture}
		\end{center}
		\(a_{i} \neq b_{j} \rightarrow\) Bewertung: \(d(i-1,j-1)\)
	\newpage
	\item Eines der letzten beiden Zeichen streichen
		\begin{center}
			\begin{tikzpicture}[every node/.style={circle,inner sep=0pt}]
				\draw (0,1) -- (2,1) -- (2,1.5) -- (0,1.5);
				\draw (1.5,1) -- (1.5,1.5);
				\draw (1.75,1.2) node[cross] {\(a_{i}\)};
				\draw (0,0) -- (1.5,0) -- (1.5,.5) -- (0,.5);
				\draw (1,0) -- (1,.5);
				\draw (1.25,.2) node {\(b_{j}\)};
			\end{tikzpicture}
		\end{center}
		Bewertung: \(d(i-1,j)\),\\ entsprechend andere Fall: \(d(i,j-1)\)
\end{itemize}
Damit gilt:
\begin{equation*}
d(i,j) = \left\{
	\begin{array}{l l}
		0 & \quad \text{für } i=0 \text{ oder } j=0\\
		\begin{array}{l l}
			\max \{&d(i-1,j-1) + 1_{a_{i} = b_{j}},\\
			&d(i-1,j),\\
			&d(i,j-1) \}
		\end{array} & \quad \text{für } i,j >0
  \end{array} \right.
\end{equation*}
Für die Laufzeit beträgt wie bei der Edierdistanz: \(\mathcal{O}(n \cdot m) \cdot \mathcal{O}(1) = \mathcal{O}(mn)\)

\subsubsection{Beispiel}
Berechen Sie die längste gemeinsame Teilfolge  der Wörter: BANANE, ANANAS.
\begin{center}
	\begin{tabular}{c|ccccccc}
		& \ & B & A & N & A & N & E \\ \hline
		& 0 & 0 & 0 & 0 & 0 & 0 & 0 \\
	A	& 0 & 0 & 1 & 1 & 1 & 1 & 1 \\
	N	& 0 & 0 & 1 & 2 & 2 & 2 & 2 \\
	A	& 0 & 0 & 1 & 2 & 3 & 3 & 3 \\
	N	& 0 & 0 & 1 & 2 & 3 & 4 & 4 \\
	A	& 0 & 0 & 1 & 2 & 3 & 4 & 4 \\
	S	& 0 & 0 & 1 & 2 & 3 & 4 & \textbf{\textcolor{red}{4}}
	\end{tabular}
\end{center}

\section{Komplexitätsklassen}
\begin{itemize}
	\item P enthält alle Problme, die sich in der Zeit \(\mathcal{O}(n^{k})\) für ein \(k>0\) lösen lassen, wobei \(n\) die Länge der Eingabe ist.
		Beispiel: Sortieren (\(\mathcal{O}(n \log n)\), Editierdistanz (\(\mathcal{O}(m \cdot n) \subseteq \mathcal{O}((m+n)^{2})\).
	\item Klasse der NP-vollständigen Probleme. Nicht in Polynoialzeit lösbar.
	
	Besteht aus allen Problemen, für die kein Algorithmus in \(\mathcal{O}(n^{k})\) bekannt ist.
	Es gilt: Wenn es ein NP-vollständiges Problem gibt, das in P liegt, dann liegen alle NP-vollständigen Probleme in P.
	
	Wichtige NP-vollständige Probleme:
	\begin{itemize}
		\item Erfüllbarkeitsproblem der Aussagenlogik (Gegeben sei eine Formel der Aussagenlogik. Ist diese erfüllbar?)
		\item Hamilton-Kreis (besitzt ein Graph einen Kreis, der jeden Knoten genau einmal besucht?)
		\item Travelling Salesmann Problem
		\item Rucksack-Problem
	\end{itemize}
\end{itemize}

\subsubsection{Anwendungen}
\begin{itemize}
	\item Erfüllbarkeitsproblem der Aussagenlogik (Bsp. Äquivalenz von Schaltkreisem)
	\item Hamilton-Pfad (Bsp. DNA Sequenzierung)
	
	Bsp. ATGCTGATT \(\rightarrow\) Bruchstücke ATG, GCT, TGC, CTG, TGA, GAT, ATT
	\begin{figure}[htbp]
		\begin{center}
			\begin{tikzpicture}[node distance=1.8cm]
				\node[state] (1) {ATG};
				\node[state] (2) [below right of=1] {TGC};
				\node[state] (3) [below right of=2] {GCT};
				\node[state] (4) [below left of=3] {CTG};
				\node[state] (5) [left of=4] {TGA};
				\node[state] (6) [above left of=5] {GAT};
				\node[state] (7) [above of=6] {ATT};
				
				\path[->]
				(1) edge node[left] {} (2)
					edge node[left] {} (5)
				(2) edge node[left] {} (3)
				(3) edge node[left] {} (4)
				(4) edge node[left] {} (5)
					edge node[left] {} (2)
				(5) edge node[left] {} (6)
				(6) edge node[left] {} (7)
					edge node[left] {} (1);

			\end{tikzpicture}
		\end{center}
	\end{figure}
	Suche nach einen Kreis in dem jedes Bruchstück genau einmal vorkommt.
\end{itemize}
Alle Probleme in NP (und damit auch alle NP-vollständigen Probleme) lassen sich in der Zeit \(2^{\mathcal{O}(n^{k})}\) entscheiden.

\section{Travelling Salesmann Problem}
\label{sec:TSP}
Gesucht ist die kürzeste Rundreise durch \(n\) Städte, wobei jede Stadt genau einmal besucht wird.
Das TSP ist NP-vollständig.

Sei \((d_{ij})_{1 \leq i, j \leq n}\) die entsprechende Entfernungsmatrix.
Wir betrachten den allgemeinen Fall in dem \(d_{ij} \neq d_{ji}\) sowie \(d_{ij} = \infty\) gelten kann.
Der naive Algorithmus prüft alle \(n!\) Kombinationen und hat eine Laufzeit in \(\Omega(n!) \cdot \mathcal{O}(n) = \Omega(n!)\).

Optimalitätsprinzip: Wenn eine optimale Rundreise bei Stadt 1 beginnt, dann durch Stadt k führt, dann muss der Weg von k durch die Städte in \(\{2, \ldots, n\} - \{k\}\) ebenfalls optimal sein.

Sein \(l(S,i)\) die Länge des kürzesten Pfades, der bei \(i\) beginnt, dann durch jedes \(j \in S\) genau einmal führt und bei \(n\) endet.
\begin{figure}[htbp]
	\begin{center}
		\begin{tikzpicture}[node distance=2cm]
			\draw (0,0) circle[radius=2pt] node[align=center, below] {i};
			\draw (2,0) circle[radius=2pt] node[align=center, below] {n};
			\draw[thick,decorate,decoration={brace,amplitude=12pt}] (2,-.5) -- (0,-.5) node[midway,below, yshift=-12pt]{s};
			\draw [zigzag] (.1,0) -- (1.9,0);
			\draw (4,0) circle[radius=2pt] node[align=center, below] {i};
			\draw (5,0) circle[radius=2pt] node[align=center, below] {j};
			\draw (7,0) circle[radius=2pt] node[align=center, below] {n};
			\draw[->] (4.1,0) -- (4.9,0) node[midway,below, yshift=-12pt]{\(d_{ij}\)};
			\draw [zigzag] (5.1,0) -- (6.9,0);
			\draw[thick,decorate,decoration={brace,amplitude=12pt}] (7,-.5) -- (5,-.5) node[midway,below, yshift=-12pt]{\(S-\{j\}\)};
		\end{tikzpicture}
	\end{center}
\end{figure}
Die Länge des kürzesten Rundweges ist dann \(l(\{1, \ldots, n-1\}, n)\).
Es gilt:
\begin{equation*}
l(S,i) = \left\{
	\begin{array}{l l}
		d_{in} & \quad \text{für } S = \varnothing \text{(keine Zwischenstädte)}\\
		\min\limits_{j \in S} \{d_{ij} + l(S-\{j\},j)\} & \quad \text{für alle } S \neq \varnothing
  \end{array} \right.
\end{equation*}

Mit Hilfe dieses Algorithmuses kann eine Matix erstellt werden, in welcher die Länge der Rundwege gepeichert werden.
In der x-Achse werden die Knoten von 1 bis \(n-1\) eingetragen und in der y-Achse die Teilmengen in aufsteigender Mächtigkeit.
Dieser besitzt eine Laufzweit von \(\mathcal{O}(2^{n-1} \cdot (n-1)) \cdot \mathcal{O}(n) = \mathcal{O}(n^{2} \cdot 2^{n})\).
Diese wächst langsamer als \(\mathcal{O}(n!)\).

Gegeben sei der nachfolgende Graph mit 4 Städten.
Gesucht ist der kürzeste Weg zur Stadt 4.
\begin{figure}[htbp]
	\begin{center}
		\begin{tikzpicture}[node distance=1.8cm]
			\node[state] (1) {1};
			\node[state] (2) [right of=1] {2};
			\node[state] (3) [below of=2] {3};
			\node[state] (4) [below of=1] {4};
			\path[-]
				(1) edge node[above] {2} (2)
					edge node[left, above] {1} (3)
					edge node[left] {2} (4)
				(2) edge node[right] {2} (3)
					edge node[right, below] {1} (4)
				(3) edge node[below] {2} (4);
		\end{tikzpicture}
	\end{center}
\end{figure}
\begin{center}
	\begin{tabular}{c|cccc}
	\{1,2,3\}	& X & X & X & Lösung: \begin{tabular}[x]{@{}c@{}c@{}}\(2+4=6\)\\\(1+5=6\)\\\(2+4=6\)\end{tabular}  \\ 
	\{2,3\}	& \begin{tabular}[x]{@{}c@{}}\(1+3=4\)\\\(2+4=6\)\end{tabular} & X & X & \\
	\{1,3\}	& X & \begin{tabular}[x]{@{}c@{}}\(2+3=5\)\\\(2+3=5\)\end{tabular} & X & \\
	\{1,2\}	& X & X & \begin{tabular}[x]{@{}c@{}}\(2+4=6\)\\\(1+3=4\)\end{tabular} & \\
	\{3\}	& \(2+2=3\) & \(2+2=4\) & X 		& \\
	\{2\}	& \(2+1=3\) & X 		& \(2+1=3\) & \\
	\{1\}	& X			& \(2+2=4\) & \(1+2=3\) & \\
	\{\(\varnothing\)\}		& 2 & 1 & 2 & \\ \hline
			& 1 & 2 & 3 & 4 
	\end{tabular}
\end{center}

\begin{shaded}
  \noindent
  \textbf{Def.:} Sei \(\varepsilon > 1\).
	Ein Minimierungsproblem heißt \(\varepsilon\)-approximierbar, wenn es einen Algorithmus mit polynomieller Laufzeit gibt, der eine Lösung liefert, die höchstems um \(\varepsilon\) größer ist als das Optimum.
\end{shaded}
Falls \(P \neq NP\) gilt, ist für kein \(\varepsilon > 1\) TSP \(\varepsilon\)-approximierbar.
Falls die Entfernungsmatrix jedoch die Dreiecksungleichung \[d_{uv} \leq d_{uw} + d_{wv}\] gilt (\(\Delta\)-TSP), dann ist das Problem \(\frac{3}{2}\)-approximierbar.
Wenn es für die Anwendung nicht notwendig ist, dass kein Punkt mehrfach besucht wird, kann die Dreiecksungleichung immer erfüllt werden, indem die Kante von \(u\) nach \(v\) durch die kürzeste Verbindung von \(u\) nach \(v\) ersetzt wird.

Ein Spezialfall des \(\Delta\)-TSP ist das Euklidischen TSP, bei dem die Entfernungen gleich dem geometrischen Abstand sind. Für jedes \(\delta > 1\) ist das Euklidische TSP in der Ebene \(1+\frac{1}{\delta}\)-approximierbar.
Der zugehörige Approximationsalgorithmus besitzt eine Laufzeit in \(\mathcal{O}(n \log(n))^{\mathcal{O}(\delta)}\).

Anwendungen des TSP:
\begin{itemize}
	\item Roboter soll Löcher in eine Platine bohren
	\item Auf einer Fertigungsstraße sollen Produkte \(P_{1}, \ldots, P_{n}\) herrgestellt werden.
		Dabei muss die Fertigungsstraße jeweils umgerüstet werden.
		Wenn \(d_{uv}\) die Zeit ist, die für das umrüsten von \(P_{U}\) nach \(P_{V}\) benötigt wird, muss ein TSP für (\(d_{uv}\)) gelöst werden..
		Für kleine \(n\) kann das exakte TSP und sonst das \(\Delta\)-TSP (Bedingung: Dreiecksungleichung)zur Approximation des Optimums verwendet werden.
	\item DNA-Sequenzierung (Erzeugung von DNA-Bruchstücken, Suche nach Über\-lap\-pungen, kürzester Pfad durch diese Knoten (Besser wäre allerdings der Aufbau einen Graphen und Suche eines euklidischen Kreises))
\end{itemize}



\section{Rucksackproblem}
Das Rucksackproblem ist ein Optimierungsproblem der Kombinatorik.
Aus einer Menge von Objekten, die jeweils ein Gewicht und einen Nutzwert haben, soll eine Teilmenge ausgewählt werden, deren Gesamtgewicht eine vorgegebene Gewichtsschranke nicht überschreitet.
Unter dieser Bedingung soll der Nutzwert der ausgewählten Objekte maximiert werden.
Anwendungen:
\begin{itemize}
	\item öffentliche Haushaltsführung
	\item Reduzierung des Verschnits (Bsp. Fließen, Folien)
	\item Logistik (Bsp. Transport mittels Frachschiff)
\end{itemize}

Gegebenen seien n Gegenstände mit den Werten \(x_{1}, \dots, x_{n}\) und gesucht sei eine Menge \(S \subseteq \{1, \dots, n\}\) mit
\(\max \sum\limits_{s \in S}x_{s}\) und \( \sum\limits_{s \in S}x_{s} \leq y \).

Das Rucksackproblem ist NP-vollständig, es lässt sich mit einem dynamischen Pro\-gram\-mier-Algorithmus wie folgt lösen:
Sei \(r(n,y)\) der Wert einer Lösung des Rucksackproblems für die Werte \(x_{1}, \dots, x_{n}\) und der Rucksackgröße \(y\) dann gilt:
\begin{itemize}
	\item \(r(n,y) = 0\) für \(n=0\)
	\item \(r(n,y) = r(n-1,y)\) für \(y>0\) und \(x_{n} > y\)
	\item Für \(n > 0\) und \(x_{n} < y\) kann der Gegenstand n entweder eingepackt oder nicht eingepackt werden
		\begin{itemize}
			\item Wenn Gegenstand nicht eingepackt wird, gilt: \[r(n,y) = r(n-1,y)\]
			\item Wenn Gegenstand n eingepackt wird: \[r(n,y) = r(n-1,y-x_{n})+x_{n}\]
		\end{itemize}
\end{itemize}
 \[r(n,y) = \left\{
			\begin{array}{l l}
				0 				& \quad \text{für } n=0\\
				r(n-1,y) 		& \quad \text{für } n>0 \wedge x_{n} > y \\
				\begin{array}{l l}
					\max \{
						r(n-1,y),\\
						r(n-1,y-x_{n})+x_{n}
					\}
				\end{array} & \quad \text{sonst}
		\end{array} \right.\]

Die laufzeit des Rucksack-Algorithmuses beträgt: \(\mathcal{O}(ny)\).
Es stellt sich daher die Frage ob dies ein polynomieller Algorithmus für das Rucksackproblem ist (woraus P=NP folgen würde)?

Die Laufzeit eines Algorithmuses wird gemessen in der Länge der Eingabe.
Im Falle des Rucksackproblems ist die Eingabe das Tupel \((x_{1}, \dots, x_{n}, y)\).
Wenn diese Werte binär codiert werden, hat dieses Tupel eine Länge \(\leq (n+1)|y| = (n+1) \log(y)+\mathcal{O}(1)\).
Die Laufzeit liegt daher in \(\Omega(ny) = \Omega(n \cdot 2^{\log(y)+\mathcal{O}(1)}) = \Omega(n \cdot 2^{|x|})\)
\begin{shaded}
	\noindent
	\textbf{Def.:} Ein Algorithmus heißt pseudopolynomiell, wenn seine Laufzeit durch ein Polynom in der Eingabelänge und der größten, in der Eingabe vorkomenden Zahl beschränkt ist.
\end{shaded}
Mit Hilfe eines NP-vollständigen Problems kann man die NP-Vollständigkeit weitere Probleme nachweisen.
Prinzip: Wenn sich mit ein angenommener pseudopolynomieller Algorithmus für ein Problem B auch für ein NP vollständiges Problem A in polynomieller Zeit lösen lässt.
\newpage
\begin{lstlisting}[language=java, caption={Pseudocode des Prinzips}]
boolean A(Input x)
	return B(f(x))
\end{lstlisting}
Dabei ``übersetzt'' f das Problem A in das Problem B.
\subsubsection{Übung}
Sei
\[KP = \bigcup_{n \geq 1} \{ (x_{1}, \dots, x_{n}, y, v_{1}, \dots, v_{n}, t) \:|\: \text{Es gibt ein } S \subseteq \{1, \ldots, n\} \text{mit}\]\[ \sum\limits_{s \in S} x_{s} \leq y \text{ und } t \leq \sum\limits_{s \in S} v_{s}\}\]
Zeigen Sie, dass KP NP-vollständig ist.

\begin{lstlisting}[language=java, caption={Beispiellösung Übung}]
set Rucksack(x1 ... xn, y)
	return KP(x1, ... xn, y, x1 ... xn)
\end{lstlisting}
Wenn KP polynomial ist, dann ist auch Rucksack polynomial. Widerspruch da Rucksack NP.